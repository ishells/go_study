
- Golang 调度器 GMP 的由来
单进程时代不需要调度器
    我们知道,一切的软件都是跑在操作系统上,真正用来干活(计算)的是CPU。
    早期的操作系统每个程序就是一个进程,直到一个程序运行完,才能进行下一个进程,就是"单进程时代"
    一切的程序只能串行发生。
    A->B->C->...(顺序执行)

    - 早期的单进程操作系统,面临2个问题:
    1.单一的执行流程,计算机只能一个任务一个任务处理。
    2.进程阻塞所带来的CPU时间浪费。
    那么能不能有多个进程来宏观一起来执行多个任务呢?
    后来操作系统就具有了最早的并发能力:多进程并发,当一个进程阻塞的时候,切换到另外等待执行的进程,这样就能尽量把CPU利用起来,CPU就不浪费了。

    - 多进程/线程时代有了调度器需求
    ![](.\img\new_os_cpu.png)

    在多进程/多线程的操作系统中,就解决了阻塞的问题,因为一个进程阻塞cpu可以立刻切换到其他进程 中去执行,
    而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。
    这样从宏观来看,似乎多个进程是在同时被运行。
    但新的问题就又出现了,进程拥有太多的资源,进程的创建、切换、销毁,都会占用很长的时间,
    CPU虽然利用起来了,但如果进程过多,CPU有很大的一部分都被用来进进行进程调度了
    怎么才能提高CPU的利用率呢?
      对于Linux操作系统来讲,cpu对进程的态度和线程的态度是一样的。
    ![](.\img\cpu_lost_time.png)
    很明显,CPU调度切换的是进程和线程。尽管线程看起来很美好,但实际上多线程开发设计会变得更加复杂,要考虑很多同步竞争等问题,如锁、竞争冲突等。
  
    - 协程来提高CPU利用率
    多进程、多线程已经提高了系统的并发能力,
    但是在当今互联网网高并发场景下,为每个任务都创建一个线程是不现实的,因为会消耗大量的内存(进程虚拟内存会占用4G3[32位操作系统],而线程也要大约4MB)。
    
    - 大量的进程/线程出现了新的问题
      高内存占用
      调度的高消耗CPU
    好了,然后工程师们就发现,其实一个线程分为"内核态"线程和"用户态"线程,
    "用户态线程"必须要绑定一个"内核态线程",但是CPU并不知道有"用户态线程"的存在,它只知道它运行的是一个"内核态线程"（Linux的PCB进程控制块）
    后来再去细化分类一下，内核线程依然叫"线程(thread)"，用户线程叫"协程(co-routine)"。

    既然一个协程(co-routine)可以绑定一个线程(thread),那么能不下能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。
    
    - 有三种协程和线程的映射关系:
      1、N:1关系
        N个协程绑定1个线程,优点就是协程在用户态线程就完成切换,不会陷入到内核态,这种切换非常的轻量快速。
        但也有很大的缺点,1个进程的所有协程都绑定在1个线程上，缺点如下：
          ① 某个程序用不了硬件的多核加速能力
          ② 一旦某个协程阻塞造成了线程阻塞，本进程的其他协程都无法执行了，这样就失去了并发的能力
      2、1:1关系
        一个协程绑定一个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1的缺点。
        但同时缺点是：
          ① 协程的创建、删除和切换的代价都由CPU完成，代价有点略显昂贵
      3、M:N关系
        M个协程绑定N个线程（一般情况下肯定是M>N），是N:1和1：1类型的结合，克服了以上两种模型的缺点，但实现起来最为复杂。
        协程跟线程是有区别的，线程由CPU调度，是抢占式的，协程由用户态调度，是协作式的，一个协程让出CPU后，才执行下一个协程。

  ![](.\img\cpu_lost_time.png)

  ![](.\img\common_concept.png)

  ![](.\img\goroutine.png)

  ![](.\img\gmp_concept.png)

  ![](.\img\gmp_concept_1.png)

  ![](.\img\go_func_style.png)

  ![](.\img\go_func_style_reason.png)